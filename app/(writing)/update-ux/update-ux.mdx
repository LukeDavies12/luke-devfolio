import BackLink from '@/comp/BackLink';
import CodeBlock from '@/comp/CodeBlock';
import InlineCode from '@/comp/InlineCode';
import PostInfoSection from '@/comp/PostInfoSection';

<BackLink href="/" text="Homepage" />

# App Router: Crafting a Clean UX for Update Pages
<span className='text-sm'>09-26-24</span>

<p className='mt-3'>Implementing updates and deletions in a Next.js App Router project offers an opportunity to enhance the user experience (UX) of your product. But without a solid grasp of the new Server Actions features, you might miss out on valuable improvements that are surprisingly easy to implement.</p>

In this post, we'll learn a pattern to make a reactive update page. **We'll focus on toggling edit states, displaying loading indicators, confirming deletions, and properly revalidating cache and rerouting.** Then we'll see this pattern in action in my application [QB Logs](https://github.com/LukeDavies12/qblogs).

## Understanding Server Actions

Before diving into the code, let's briefly understand what Server Actions are. Server Actions allow you to define functions that run on the server but can be invoked from client components. This means you can keep your server-side logic encapsulated while still interacting with it directly from your client-side code.

## Creating our Component

To create an interactive form, we need to manage several state variables within our component:

- <InlineCode>isEditing</InlineCode>: Determines if the form is in edit mode.
- <InlineCode>formData</InlineCode>: Holds the current form values.
- <InlineCode>originalData</InlineCode>: Keeps a copy of the original data for reset purposes.
- <InlineCode>isPending</InlineCode>: Indicates if an asynchronous action is in progress.
- <InlineCode>error</InlineCode>: Stores any error messages.

Let's break down the steps to set up and use these states effectively.

### Step 1: Initialize State Variables

<CodeBlock language="tsx" code=
{`
"use client";

import React, { useEffect, useState } from 'react';

export default function DataUpdateComponent({ dataItem }) {
    const [isEditing, setIsEditing] = useState(false);       // Tracks if we're in edit mode
    const [formData, setFormData] = useState({});            // Holds current form values
    const [originalData, setOriginalData] = useState({});    // Keeps a copy of the original data
    const [isPending, setIsPending] = useState(false);       // Indicates if an async action is in progress
    const [error, setError] = useState(null);                // Stores any error messages

    // ...
}
`}
/>

### Step 2: Sync State with Incoming Data

<CodeBlock language="tsx" code=
{`
"use client";

import React, { useEffect, useState } from 'react';

export default function DataUpdateComponent({ dataItem }) {
    const [isEditing, setIsEditing] = useState(false);       // Tracks if we're in edit mode
    const [formData, setFormData] = useState({});            // Holds current form values
    const [originalData, setOriginalData] = useState({});    // Keeps a copy of the original data
    const [isPending, setIsPending] = useState(false);       // Indicates if an async action is in progress
    const [error, setError] = useState(null);                // Stores any error messages

    // Synchronize formData and originalData with dataItem prop
    useEffect(() => { // [!code ++]
      if (dataItem) { // [!code ++]
        setFormData(dataItem); // [!code ++]
        setOriginalData(dataItem); // [!code ++]
      } // [!code ++]
    }, [dataItem]); // [!code ++]

    return (
      // ...
    );
}
`}
/>

### Step 3: Render the Form with Edit Controls

<CodeBlock language="tsx" code=
{`
"use client";

import React, { useEffect, useState } from 'react';

export default function DataUpdateComponent({ dataItem }) {
    const [isEditing, setIsEditing] = useState(false);       // Tracks if we're in edit mode
    const [formData, setFormData] = useState({});            // Holds current form values
    const [originalData, setOriginalData] = useState({});    // Keeps a copy of the original data
    const [isPending, setIsPending] = useState(false);       // Indicates if an async action is in progress
    const [error, setError] = useState(null);                // Stores any error messages

    // Synchronize formData and originalData with dataItem prop
    useEffect(() => {
      if (dataItem) {
        setFormData(dataItem); 
        setOriginalData(dataItem); 
      }
    }, [dataItem]); 

    return (
      <> // [!code ++]
        <h2 className="text-2xl font-bold mb-4">Data</h2> // [!code ++]
        {error && <p className="text-red-500 mb-4">{error}</p>} // [!code ++]
        <form> // [!code ++]
          {/* Replace with your actual form fields */} // [!code ++]
          {/* Example: <input value={formData.name} onChange={...} /> */} // [!code ++]
          <div className="mt-4 flex gap-4 justify-end"> // [!code ++]
            {isEditing ? ( // [!code ++]
              <> // [!code ++]
                <button type="button" onClick={cancelEdit}> // [!code ++]
                  Cancel // [!code ++]
                </button> // [!code ++]
                <button type="submit"> // [!code ++]
                  {isPending ? 'Updating Data...' : 'Update Data'} // [!code ++]
                </button> // [!code ++]
              </> // [!code ++]
            ) : ( // [!code ++]
              <> // [!code ++]
                <button type="button" onClick={handleDelete}> // [!code ++]
                  {isPending ? 'Deleting Data...' : 'Delete Data'} // [!code ++]
                </button> // [!code ++]
                <button type="button" onClick={() => setIsEditing(true)}> // [!code ++]
                  Edit Data // [!code ++]
                </button> // [!code ++]
              </> // [!code ++]
            )} // [!code ++]
          </div> // [!code ++]
        </form> // [!code ++]
      </> // [!code ++]
    );
}
`}
/>

### Step 4: Handle Edit Mode and Actions

<CodeBlock language="tsx" code=
{`
"use client";

import React, { useEffect, useState } from 'react';

export default function DataUpdateComponent({ dataItem }) {
    const [isEditing, setIsEditing] = useState(false);       // Tracks if we're in edit mode
    const [formData, setFormData] = useState({});            // Holds current form values
    const [originalData, setOriginalData] = useState({});    // Keeps a copy of the original data
    const [isPending, setIsPending] = useState(false);       // Indicates if an async action is in progress
    const [error, setError] = useState(null);                // Stores any error messages

    // Synchronize formData and originalData with dataItem prop
    useEffect(() => {
      if (dataItem) {
        setFormData(dataItem); 
        setOriginalData(dataItem); 
      }
    }, [dataItem]); 

    const cancelEdit = () => { // [!code ++]
      setIsEditing(false); // [!code ++]
      setFormData(originalData); // Reset to original data // [!code ++]
    }; // [!code ++]

    const handleUpdate = async (event) => { // [!code ++]
      event.preventDefault(); // [!code ++]
      setIsPending(true); // [!code ++]
      try { // [!code ++]
        // Call your update Server Action here // [!code ++]
        // await updateData(formData); // [!code ++]
        setIsEditing(false); // [!code ++]
      } catch (err) { // [!code ++]
        setError('Failed to update data.'); // [!code ++]
      } finally { // [!code ++]
        setIsPending(false); // [!code ++]
      } // [!code ++]
    }; // [!code ++]

    const handleDelete = async () => { // [!code ++]
      if (!confirm('Are you sure you want to delete this item?')) return; // [!code ++]
      setIsPending(true); // [!code ++]
      try { // [!code ++]
        // Call your delete Server Action here // [!code ++]
        // await deleteData(dataItem.id); // [!code ++]
      } catch (err) { // [!code ++]
        setError('Failed to delete data.'); // [!code ++]
      } finally { // [!code ++]
        setIsPending(false); // [!code ++]
      } // [!code ++]
    }; // [!code ++]

    return (
      <> 
        <h2 className="text-2xl font-bold mb-4">Data</h2> 
        {error && <p className="text-red-500 mb-4">{error}</p>} 
        <form> 
          {/* Replace with your actual form fields */} 
          {/* Example: <input value={formData.name} onChange={...} /> */} 
          <div className="mt-4 flex gap-4 justify-end"> 
            {isEditing ? ( 
              <> 
                <button type="button" onClick={cancelEdit}> 
                  Cancel 
                </button> 
                <button type="submit"> 
                  {isPending ? 'Updating Data...' : 'Update Data'} 
                </button> 
              </> 
            ) : ( 
              <> 
                <button type="button" onClick={handleDelete}> 
                  {isPending ? 'Deleting Data...' : 'Delete Data'} 
                </button> 
                <button type="button" onClick={() => setIsEditing(true)}> 
                  Edit Data 
                </button> 
              </> 
            )} 
          </div> 
        </form> 
      </> 
    );
}
`}
/>

## Creating our Server Actions

Here's how we can implement the Update and Delete Server Actions:
<CodeBlock language="tsx" code=
{`
"use server";

import { db } from "@/lib/db"; // Replace with your actual database connection
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

export async function updateData(data: FormData) {
    try {
      await db.update({
        where: { id: data.id },
        data: { ...data },
      });

      revalidatePath("/path-to-revalidate"); // Replace with the actual path you want to revalidate
      redirect("/new-page"); // Replace with the path you want to redirect to
    } catch (error) {
      console.error("Error updating data:", error);
      throw new Error("Failed to update data.");
    }
  }

  export async function deleteData(id: number) {
    try {
      await db.delete({
        where: { id },
      });

      revalidatePath("/path-to-revalidate"); // Replace with the actual path you want to revalidate
      redirect("/new-page"); // Replace with the path you want to redirect to
    } catch (error) {
      console.error("Error deleting data:", error);
      throw new Error("Failed to delete data.");
    }
}
`}
/>

<PostInfoSection>
In Next.js, **`revalidatePath`** forces the regeneration of a specific route's cached page, ensuring it reflects updated data after changes like database updates or deletions. For more details, see [the Next.js revalidatePath documentation](https://nextjs.org/docs/app/api-reference/functions/revalidatePath).
</PostInfoSection>

And now we can implement these functions in our Client Component. For example, in the handleUpdate function:

<CodeBlock language="tsx" code=
{`
await updateData(formData)
`}
/>

Similarly, in the handleDelete function:

<CodeBlock language="tsx" code=
{`
await deleteData(id)
`}/>

## Using our Component with a Dynamic Route

To use this component with a dynamic route in Next.js, you'll need to set up a route that loads the relevant data item based on the URL. Here's how to achieve this:

### Step 1: Get Date from the Server

<CodeBlock language="tsx" code=
{`
"server only";

import { db } from '@/lib/db'; // Replace with your actual database connection

export async function getDataItem(id) {
    try {
      const dataItem = await db.findUnique({ where: { id }, });
      return dataItem;
    }
    catch (error) {
      console.error("Error fetching data:", error);
      throw new Error("Failed to fetch data.");
    }
}
`} 
/>

<PostInfoSection>
#### Use Server vs Server Only


The **`'use server'`** directive is used at the top of a file to mark a React component as a Server Component. This means the component will be rendered on the server and cannot include client-side interactivity or state.

The **`'server-only'`** utility function ensures that certain modules or code are only imported and executed on the server. This helps prevent sensitive data or server-only logic from being bundled into the client-side code.

For more details, check out the [Next.js Composition Patterns documentation](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns).
</PostInfoSection>

### Step 2: Create a Dynamic Route

<CodeBlock language="tsx" code=
{`
import { getDataItem } from '@/lib/data'
import { DataUpdateComponent } from '@/components/DataUpdateComponent'

export default async function Page({ params }: { params: { id: string } }) {
    const dataItem = await getDataItem(params.id)

    return (
      <div>
        <h1>Update Item {params.id}</h1>
        <p>Use the form below to update the details for item {params.id}.</p>
        <DataUpdateComponent dataItem={dataItem} />
      </div>
    )
}
`}
/>

Now we have a fully functional update form that can be used in a Next.js app. This pattern can be extended to include additional features like form validation, file uploads, or multi-step forms. But for now, let's see how this pattern is applied in a real-world example.

## QB Logs Demo

<video controls className='w-full'>
  <source src="/UpdateUXDemo.mov" type="video/mp4"/>
</video>
<br/>
Code: [Github Repo](https://github.com/LukeDavies12/qblogs)
- **Get Data**: <InlineCode>data/app/get/play.ts</InlineCode>
- **Dynamic Route**: <InlineCode>app/(app)/game/play/[id]/page.tsx</InlineCode>
- **Server Actions (Update/Delete)**: <InlineCode>data/app/actions/Play.ts</InlineCode>
- **Client Component**: <InlineCode>app/(app)/game/play/[id]/PlayDataCorrection.tsx</InlineCode>

## Conclusion

By using Server Actions and reactive state management you can greatly improve the experience of updating forms in your Next.js app. **This pattern scales well, whether for blog posts, data entry, or complex datasets like in QB Logs.** Have questions or need help implementing this? Reach out to me on [Twitter](https://twitter.com/Luke_Davies09).